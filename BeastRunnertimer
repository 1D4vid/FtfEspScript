-- LocalScript: RunnerMinimalModern.local.lua
-- Coloque em StarterPlayerScripts (LocalScript)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Root ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "RunnerMinimalGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

-- Helpers
local function tween(inst, props, info)
    info = info or TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TweenService:Create(inst, info, props):Play()
end

local function makeCorner(parent, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    c.Parent = parent
    return c
end

local function makeStroke(parent, thickness, transparency)
    local s = Instance.new("UIStroke")
    s.Thickness = thickness or 1
    s.Transparency = transparency or 0.6
    s.Parent = parent
    return s
end

local function percentText(v)
    return tostring(math.floor(v * 100 + 0.5)) .. "%"
end

-- Minimal bottom hint (small and subtle)
local hint = Instance.new("Frame")
hint.Name = "MinimalHint"
hint.AnchorPoint = Vector2.new(0.5, 1)
hint.Size = UDim2.new(0, 260, 0, 36)
hint.Position = UDim2.new(0.5, 0, 1, -18)
hint.BackgroundColor3 = Color3.fromRGB(30, 30, 34)
hint.BorderSizePixel = 0
hint.Parent = screenGui
makeCorner(hint, 10)
hint.ZIndex = 50
hint.BackgroundTransparency = 1 -- start hidden, will tween in

local hintText = Instance.new("TextLabel")
hintText.Name = "Text"
hintText.Size = UDim2.new(1, -20, 1, 0)
hintText.Position = UDim2.new(0, 10, 0, 0)
hintText.BackgroundTransparency = 1
hintText.Font = Enum.Font.Gotham
hintText.TextSize = 14
hintText.TextScaled = true
hintText.TextColor3 = Color3.fromRGB(235,235,235)
hintText.Text = 'Pressione "L" para abrir o menu'
hintText.TextXAlignment = Enum.TextXAlignment.Left
hintText.Parent = hint
makeStroke(hintText, 1, 0.7)

-- Minimal menu (compact and modern)
local menu = Instance.new("Frame")
menu.Name = "RunnerMenu"
menu.AnchorPoint = Vector2.new(0.5, 0.5)
menu.Size = UDim2.new(0, 320, 0, 144)
menu.Position = UDim2.new(0.5, 0, 0.45, 0)
menu.BackgroundColor3 = Color3.fromRGB(22, 22, 26)
menu.BorderSizePixel = 0
menu.Visible = false
menu.Parent = screenGui
makeCorner(menu, 12)
menu.ZIndex = 60

local txtTitle = Instance.new("TextLabel")
txtTitle.Size = UDim2.new(1, -24, 0, 28)
txtTitle.Position = UDim2.new(0, 12, 0, 12)
txtTitle.BackgroundTransparency = 1
txtTitle.Font = Enum.Font.GothamBold
txtTitle.TextSize = 16
txtTitle.TextColor3 = Color3.fromRGB(245,245,245)
txtTitle.Text = "Runner"
txtTitle.TextXAlignment = Enum.TextXAlignment.Left
txtTitle.Parent = menu

local txtDesc = Instance.new("TextLabel")
txtDesc.Size = UDim2.new(1, -24, 0, 16)
txtDesc.Position = UDim2.new(0, 12, 0, 40)
txtDesc.BackgroundTransparency = 1
txtDesc.Font = Enum.Font.Gotham
txtDesc.TextSize = 12
txtDesc.TextColor3 = Color3.fromRGB(170,170,170)
txtDesc.Text = "Opções de exibição"
txtDesc.TextXAlignment = Enum.TextXAlignment.Left
txtDesc.Parent = menu

-- Row: toggle
local row = Instance.new("Frame")
row.Size = UDim2.new(1, -24, 0, 40)
row.Position = UDim2.new(0, 12, 0, 64)
row.BackgroundTransparency = 1
row.Parent = menu

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0.68, 0, 1, 0)
label.BackgroundTransparency = 1
label.Font = Enum.Font.Gotham
label.TextSize = 14
label.TextColor3 = Color3.fromRGB(235,235,235)
label.Text = "Contador de tempo (runner)"
label.TextXAlignment = Enum.TextXAlignment.Left
label.Parent = row

local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0.32, 0, 0.72, 0)
toggleBtn.Position = UDim2.new(0.68, 0, 0.14, 0)
toggleBtn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
toggleBtn.BorderSizePixel = 0
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
toggleBtn.Text = "OFF"
toggleBtn.Parent = row
makeCorner(toggleBtn, 8)

-- Row: mode (compact segmented)
local segLabel = Instance.new("TextLabel")
segLabel.Size = UDim2.new(1, -24, 0, 18)
segLabel.Position = UDim2.new(0, 12, 0, 106)
segLabel.BackgroundTransparency = 1
segLabel.Font = Enum.Font.Gotham
segLabel.TextSize = 12
segLabel.TextColor3 = Color3.fromRGB(170,170,170)
segLabel.Text = "Método"
segLabel.TextXAlignment = Enum.TextXAlignment.Left
segLabel.Parent = menu

local seg = Instance.new("Frame")
seg.Size = UDim2.new(0, 200, 0, 28)
seg.Position = UDim2.new(1, -212, 0, 108)
seg.BackgroundColor3 = Color3.fromRGB(28,28,32)
seg.BorderSizePixel = 0
seg.Parent = menu
makeCorner(seg, 8)

local btnReactive = Instance.new("TextButton")
btnReactive.Size = UDim2.new(0.5, -1, 1, -2)
btnReactive.Position = UDim2.new(0, 1, 0, 1)
btnReactive.BackgroundTransparency = 0
btnReactive.BackgroundColor3 = Color3.fromRGB(86, 101, 242)
btnReactive.Font = Enum.Font.Gotham
btnReactive.TextSize = 12
btnReactive.Text = "Reativo"
btnReactive.TextColor3 = Color3.fromRGB(255,255,255)
btnReactive.Parent = seg
makeCorner(btnReactive, 6)

local btnHeartbeat = Instance.new("TextButton")
btnHeartbeat.Size = UDim2.new(0.5, -1, 1, -2)
btnHeartbeat.Position = UDim2.new(0.5, 1, 0, 1)
btnHeartbeat.BackgroundTransparency = 0
btnHeartbeat.BackgroundColor3 = Color3.fromRGB(54, 58, 64)
btnHeartbeat.Font = Enum.Font.Gotham
btnHeartbeat.TextSize = 12
btnHeartbeat.Text = "Heartbeat"
btnHeartbeat.TextColor3 = Color3.fromRGB(210,210,210)
btnHeartbeat.Parent = seg
makeCorner(btnHeartbeat, 6)

-- State
local runnerEnabled = false
local mode = "reactive" -- "reactive" or "heartbeat"
local state = {
    heartbeatConn = nil,
    playersConn = nil,
    perPlayer = {} -- [player] = {charConn, beastAdded, beastRemoved, numberConn}
}

-- Functions for label creation & removal
local function createLabel(player)
    if not player or player == LocalPlayer or not player.Character then return nil end
    local char = player.Character
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 5)
    if not hrp then return nil end

    local bb = hrp:FindFirstChild("BeastPowerBillboard")
    if not bb then
        bb = Instance.new("BillboardGui")
        bb.Name = "BeastPowerBillboard"
        bb.Size = UDim2.new(2, 0, 1, 0)
        bb.StudsOffset = Vector3.new(0, 3, 0)
        bb.AlwaysOnTop = true
        bb.LightInfluence = 1
        bb.Parent = hrp

        local label = Instance.new("TextLabel")
        label.Name = "BeastPowerLabel"
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.GothamBold
        label.TextSize = 20
        label.TextScaled = true
        label.Text = ""
        label.TextColor3 = Color3.fromRGB(255,255,255)
        label.Parent = bb

        local stroke = Instance.new("UIStroke")
        stroke.Thickness = 1.5
        stroke.Transparency = 0.45
        stroke.Color = Color3.fromRGB(0,0,0)
        stroke.Parent = label
    end
    return bb:FindFirstChild("BeastPowerLabel")
end

local function destroyBillboards()
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character then
            local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local bb = hrp:FindFirstChild("BeastPowerBillboard")
                if bb then bb:Destroy() end
            end
        end
    end
end

-- Heartbeat updater (polling)
local function heartbeatUpdate()
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character then
            local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local bb = hrp:FindFirstChild("BeastPowerBillboard")
                if bb then
                    local label = bb:FindFirstChild("BeastPowerLabel")
                    if label then
                        local beast = pl.Character:FindFirstChild("BeastPowers")
                        if beast then
                            local nv = beast:FindFirstChildOfClass("NumberValue")
                            if nv then
                                label.Text = percentText(nv.Value)
                            else
                                label.Text = ""
                            end
                        else
                            label.Text = ""
                        end
                    end
                end
            end
        end
    end
end

-- Reactive: connect NumberValue.Changed per player character
local function connectReactive(pl, char)
    if not pl or not char then return end
    state.perPlayer[pl] = state.perPlayer[pl] or {}
    local entry = state.perPlayer[pl]

    -- cleanup previous numberConn
    if entry.numberConn then
        entry.numberConn:Disconnect()
        entry.numberConn = nil
    end
    if entry.beastAdded then
        entry.beastAdded:Disconnect()
        entry.beastAdded = nil
    end
    if entry.beastRemoved then
        entry.beastRemoved:Disconnect()
        entry.beastRemoved = nil
    end

    local function tryConnect()
        if not char or not char.Parent then return end
        local beast = char:FindFirstChild("BeastPowers")
        local label = createLabel(pl)
        if beast then
            local nv = beast:FindFirstChildOfClass("NumberValue")
            if nv then
                if label then label.Text = percentText(nv.Value) end
                entry.numberConn = nv.Changed:Connect(function()
                    if label then label.Text = percentText(nv.Value) end
                end)
            else
                if label then label.Text = "" end
            end
        else
            if label then label.Text = "" end
        end
    end

    entry.beastAdded = char.ChildAdded:Connect(function(child)
        if child.Name == "BeastPowers" then
            task.wait(0.05)
            tryConnect()
        end
    end)
    entry.beastRemoved = char.ChildRemoved:Connect(function(child)
        if child.Name == "BeastPowers" then
            if entry.numberConn then entry.numberConn:Disconnect() entry.numberConn = nil end
            local label = createLabel(pl)
            if label then label.Text = "" end
        end
    end)

    tryConnect()
end

-- Attach char listener per player
local function attachPlayer(pl)
    if not pl then return end
    state.perPlayer[pl] = state.perPlayer[pl] or {}
    local entry = state.perPlayer[pl]
    if entry.charConn then
        entry.charConn:Disconnect()
        entry.charConn = nil
    end
    entry.charConn = pl.CharacterAdded:Connect(function(char)
        task.wait(0.4)
        createLabel(pl)
        if mode == "reactive" then
            connectReactive(pl, char)
        end
    end)
end

local function attachExisting()
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            createLabel(pl)
            attachPlayer(pl)
            if mode == "reactive" and pl.Character then
                connectReactive(pl, pl.Character)
            end
        end
    end
end

local function cleanupAll()
    if state.heartbeatConn then
        state.heartbeatConn:Disconnect()
        state.heartbeatConn = nil
    end
    if state.playersConn then
        state.playersConn:Disconnect()
        state.playersConn = nil
    end
    for pl, entry in pairs(state.perPlayer) do
        if entry.charConn then entry.charConn:Disconnect() end
        if entry.beastAdded then entry.beastAdded:Disconnect() end
        if entry.beastRemoved then entry.beastRemoved:Disconnect() end
        if entry.numberConn then entry.numberConn:Disconnect() end
        state.perPlayer[pl] = nil
    end
    destroyBillboards()
end

local function enableHeartbeat()
    cleanupAll()
    attachExisting()
    state.playersConn = Players.PlayerAdded:Connect(function(pl)
        if pl ~= LocalPlayer then
            attachPlayer(pl)
            task.wait(0.4)
            createLabel(pl)
        end
    end)
    state.heartbeatConn = RunService.Heartbeat:Connect(heartbeatUpdate)
end

local function enableReactive()
    cleanupAll()
    attachExisting()
    state.playersConn = Players.PlayerAdded:Connect(function(pl)
        if pl ~= LocalPlayer then
            attachPlayer(pl)
            task.wait(0.4)
            if pl.Character then connectReactive(pl, pl.Character) end
        end
    end)
end

local function enableRunner()
    if runnerEnabled then return end
    runnerEnabled = true
    toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 160, 90)
    toggleBtn.Text = "ON"
    if mode == "heartbeat" then enableHeartbeat() else enableReactive() end
end

local function disableRunner()
    if not runnerEnabled then return end
    runnerEnabled = false
    toggleBtn.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
    toggleBtn.Text = "OFF"
    cleanupAll()
end

-- UI bindings
toggleBtn.MouseButton1Click:Connect(function()
    if runnerEnabled then disableRunner() else enableRunner() end
end)

btnReactive.MouseButton1Click:Connect(function()
    if mode == "reactive" then return end
    mode = "reactive"
    btnReactive.BackgroundColor3 = Color3.fromRGB(86,101,242)
    btnReactive.TextColor3 = Color3.fromRGB(255,255,255)
    btnHeartbeat.BackgroundColor3 = Color3.fromRGB(54,58,64)
    btnHeartbeat.TextColor3 = Color3.fromRGB(210,210,210)
    if runnerEnabled then
        disableRunner()
        task.delay(0.06, enableRunner)
    end
end)

btnHeartbeat.MouseButton1Click:Connect(function()
    if mode == "heartbeat" then return end
    mode = "heartbeat"
    btnHeartbeat.BackgroundColor3 = Color3.fromRGB(86,101,242)
    btnHeartbeat.TextColor3 = Color3.fromRGB(255,255,255)
    btnReactive.BackgroundColor3 = Color3.fromRGB(54,58,64)
    btnReactive.TextColor3 = Color3.fromRGB(210,210,210)
    if runnerEnabled then
        disableRunner()
        task.delay(0.06, enableRunner)
    end
end)

-- Toggle menu with L (simple and minimal animation)
local menuVisible = false
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.L then
        menuVisible = not menuVisible
        if menuVisible then
            menu.Visible = true
            menu.BackgroundTransparency = 1
            menu.Position = UDim2.new(0.5, 0, 0.4, 0)
            tween(menu, {Position = UDim2.new(0.5, 0, 0.45, 0), BackgroundTransparency = 0}, TweenInfo.new(0.18))
        else
            tween(menu, {Position = UDim2.new(0.5, 0, 0.38, 0), BackgroundTransparency = 1}, TweenInfo.new(0.14))
            task.delay(0.14, function() if menu then menu.Visible = false end end)
        end
    end
end)

-- Show hint for 5 seconds (minimal fade/slide)
task.spawn(function()
    task.wait(0.15)
    hint.Position = UDim2.new(0.5, 0, 1, 12)
    hint.BackgroundTransparency = 1
    tween(hint, {Position = UDim2.new(0.5, 0, 1, -18), BackgroundTransparency = 0}, TweenInfo.new(0.18))
    task.wait(5)
    tween(hint, {Position = UDim2.new(0.5, 0, 1, 28), BackgroundTransparency = 1}, TweenInfo.new(0.16))
    task.delay(0.16, function() if hint and hint.Parent then hint:Destroy() end end)
end)

-- Cleanup on player leaving
Players.PlayerRemoving:Connect(function(pl)
    local e = state.perPlayer[pl]
    if e then
        if e.charConn then e.charConn:Disconnect() end
        if e.beastAdded then e.beastAdded:Disconnect() end
        if e.beastRemoved then e.beastRemoved:Disconnect() end
        if e.numberConn then e.numberConn:Disconnect() end
        state.perPlayer[pl] = nil
    end
end)

-- End of script
